% ===========================================
% Learning Materials and Set Up
% Written by: Braidan Duffy
%
% Date: 06/13/2022
% Last Revision: 06/13/2022
% ============================================

\setchapterstyle{koa}
\chapter{Learning Materials and Setup}
\setchapterpreamble[u]{\margintoc}
\labch{b1_learning_materials}

This course will require you to become familiar with different software packages and get you hands on with real-world electronics hardware.
In this chapter, we will go into the required course material and give you an overview of what it is, how to set it up, and what you will be expected to know.

These are for your reference, so please follow these instructions closely and pay attention to the component overview parts so you can have more time playing and experimenting than troubleshooting.

% \section*{Autodesk Fusion 360}

%     \subsection*{Account Setup}

%     \subsection*{Installation}

%     \subsection*{Joining the Class}

% \section*{Fritzing}

%     \subsection*{Download and Installation}

% \section*{DrawIO}

%     \subsection*{Download}

% \section*{Git for Windows}

%     \subsection*{Installation}

%     \subsection*{Initializing your credentials}

% \section*{GitHub}

%     \subsection*{Creating an account}

\section{Arduino IDE}
\todo{Include Arduino image near section header or in corner}
This entire course hinges on you being able to program microcontroller boards with an Integrated Development Environment (IDE).
Technically, the Arduino Megas can be programmed using Atmel Studio, but that application has a very steep learning curve and the Arduino foundation has done a fantastic job simplifying the whole process so anyone - young or old - can quickly begin programming.
The Arduino IDE has the ability to download and import custom boards and third party libraries, enabling you to program a wide range of microcontrollers for almost any application imaginable.
It also has the whole compiling toolchain built into the backend, so all you need to worry about is ensuring the proper configs are in place and press a single button.
This makes it a very useful tool for learning, but this IDE is limited if you want to expand your scope beyond a single test or project file and want to do something more complicated.
We will discuss an alternative later.

    \subsection*{Installation}
    For now, navigate to the Arduino IDE download page (\url{https://www.arduino.cc/en/software}) and download the latest version for you machine's operating system.
    \marginnote{Note: as of July 2022, the current Arduino IDE version is 1.8.19}
    You may elect to donate to the Arduino Foundation (it's tax-deductible!) or just download the IDE without donating.
    Once the installer is downloaded, execute it and follow the steps to install the IDE.

    First, accept the software end usage license agreement.

    \begin{figure}[h!]
        \labfig{arduino_license}
        \includegraphics[height=3in]{learning_materials/arduino_setup/1-agreement.PNG}
        \caption[Arduino License]{Accept the license agreement for installing the Arduino IDE}
    \end{figure}

    On the next page you will see some additional options for the install.
    Select all of the additional options as this will pre-install some board drivers and shortcuts, making the IDE easier to use initially.

    \begin{figure}[h!]
        \labfig{arduino_license}
        \includegraphics[height=3in]{learning_materials/arduino_setup/2-options.PNG}
        \caption[Arduino Install Options]{Select all of the additional options for installing the Arduino IDE}
    \end{figure}

    Finally, you will need to specify the install location.
    For 99.9\% of users, the default install location will suffice.
    Be sure to keep this location in mind if you elect to install Visual Studio Code with the Arduino extension.

    \begin{figure}[h!]
        \labfig{arduino_license}
        \includegraphics[height=3in]{learning_materials/arduino_setup/3-location.PNG}
        \caption[Arduino Location]{Specify the install location for the Arduino IDE}
    \end{figure}

\section{Visual Studio Code}
\todo{Include VS code symbol near section in corner}
A superior alternative to the Arduino IDE is Visual Studio Code.
This is a fully-fledge IDE with support for a multitude of languages, version control software, filetypes, and editing experiences.
Basically, whatever you want to do with VS Code, you should be able to with the right combination of extensions and workspace layout.
Speaking of which, one of the most useful features of VS Code is the workspace.
It conveniently locates all of your working directories and files into a central location with easy access to edit and move as you please - irregardless of the files' and directories' locations on your filesystem.
This can make it really easy to do large projects, like organize source code folders for a project-based course, or write lecture notes that have tons of PDFs, build files, data files, source codes, and images...

\begin{figure}[h!]
    \labfig{vs_code_workspace}
    \includegraphics[height=4.5in]{learning_materials/vs_code_setup/workspace.PNG}
    \caption[VS Code workspace]{Workspace within the VS Code application, circled in red.
    The window shown is configured to use the \href{https://fonts.google.com/specimen/Fira+Code}{Fira Code Font}, and Midnight Blue color scheme.}
\end{figure}
    
    \subsection*{Installation}
    To install VS Code, navigate to the download site at \url{https://code.visualstudio.com/download} and select the version appropriate for your operating system.
    \marginnote{For convience, this guide will only cover the Windows install.
    The process should be similar on other operating systems, but please consult other install guides for clarifications.}
    When the installer finishes downloading, open it and accept the license on the first screen.

    \begin{figure}[h!]
        \labfig{vs_code_license}
        \includegraphics[height=3in]{learning_materials/vs_code_setup/1-agreement.PNG}
        \caption[VS Code License]{Accept the license agreement for installing VS Code}
    \end{figure}

    Press "Next" and select all of the options on the next page.
    The first option will do exactly as advertised, there will be a new icon on your computer desktop.
    The second option will allow you to open files directly into VS Code from the file explorer - a feature that is useful for quickly adding files to your workspace.
    The third option will do the same as the previous, but for directories - this again is convenient for quickly adding folders to your workspace.
    The fourth option will tell the filesystem to automatically open supported code files (.cpp, .h, .py, .jar, etc.) in VS Code for easy access.
    And the fifth and final option adds VS Code to the system path.
    This last option can make executing custom scripts and running some VS Code extensions a little easier.

    \begin{figure}[h!]
        \labfig{vs_code_tasks}
        \includegraphics[height=3in]{learning_materials/vs_code_setup/2-additional_tasks.PNG}
        \caption[VS Code Additional Tasks]{Select all of the additional tasks on this page}
    \end{figure}

    Finally, you will be ready to install VS Code!
    Press "Install" on the next page and let the rocks and electrons do their work.
    Be sure to restart your system once the application is installed!

    \begin{figure}[h!]
        \labfig{vs_code_install}
        \includegraphics[height=3in]{learning_materials/vs_code_setup/3-install.PNG}
        \caption[VS Code Install]{Press button. Install VS Code}
    \end{figure}

    \subsection*{Arduino and C++ Extensions}
    To get started with your new instance of Visual Studio code, we will install the Arduino and C++ code extensions.
    These extensions will allow you to compile and upload Arduino code, just like you would in the Arduino IDE, but simultaneously have greater flexibility with the code workspace, version control, etc.

    To begin, navigate to the extensions tab of the VS Code window, shown below.

    \begin{figure}[h!]
        \labfig{vs_code_extension_tab}
        \includegraphics[height=3in]{learning_materials/vs_code_setup/B1-extensions_tab.PNG}
        \caption[VS Code Extension Tab]{Open the extensions tab using the menu bar to the left of the screen (circled in red)}
    \end{figure}

    In the search bar near the top of the menu, type "Arduino" and find the Arduino Extension published by Microsoft. \sidenote{Should be the first result}
    Click on the little "Install" box and wait for VS Code perform its magic.
    After it successfully installs, you will notice the "Install" button has been replaced by a gear symbol.
    This is a shortcut to the extension preferences.
    Click on the icon and select "Extension Settings" - this will open a new tab in your VS Code window with a bunch of configurations.

    Navigate to the option called "Arduino: Path" towards the bottom of the page.
    Here, paste the location to the Arduino installation folder on your machine.
    If you did the default installation path on windows it will be \lstinline[]{C:\Program Files (x86)\Arduino}.

    \marginnote{For convience, I also suggest unchecking the two options: "Arduino: Analyze on Open" and "Arduino: Analyze on Change".
    This will improve performance by not compiling the script every time you make a change and save it, something that can take a very long time with complicated programs.}

    \begin{figure}[h!]
        \labfig{vs_code_arduino_location}
        \includegraphics[height=3in]{learning_materials/vs_code_setup/B2-arduino_location.PNG}
        \caption[VS Code Arduino Location]{Specify the location of the Arduino install folder on your machine in the "Arduino: Path" option (circled in red).}
    \end{figure}

    Next, as before, open the extensions tab and search for "C/C++".
    Install the C/C++ Extension published by Microsoft (again, it should be the first result) and reload the VS Code window, if prompted.
    This will enable VS Code to edit and interact with the C++ files Arduino uses!

    With this completed, you may now use VS Code to program your Arduino boards!

    \subsection*{PlatformIO Extension}
    A far superior embedded programming toolchain is provided by PlatformIO.
    This is a cross-platform high performance compiler and IDE for a wide variety of embedded platforms.
    It has superior compilation performance compared to the stock Arduino toolchain and has a project-based structure. This makes it the better platform to use for large coding projects.
    
    Better yet, the core of PlatformIO is written in Python and can be executed through the terminal.
    this gives it incredible flexibility in allowing users to use the dedicated PlatformIO IDE application or VS Code.
    Here, we will use the VS Code PlatformIO extension so that we can better integrate it with our code workspaces and version control.

    As before, open the extensions tab shown in Figure \ref{fig:vs_code_extension_tab} and type "PlatformIO" in the search box.
    Click on the "Install" button in the bottom right corner of the PlatformIO IDE extension and allow the gerbils within VS Code to spin their wheels.
    When it has finished installing, you may need to reload the VS Code window - do so, if prompted.
    \marginnote{This install make take longer than the others as it needs to install the entire PlatformIO Core backend in addition to the extension. 
    This may be expedited by having a high-speed internet connection, but your mileage may vary.}

    With this extension installed, you can now begin to do some really cool things, programatically speaking.
    I implore you to explore the PlatformIO IDE on your own and use it to program your projects through this course!

\pagebreak

\section*{Arduino Kit Introduction}
\marginnote{There is a really cool simulator made in the browser that you may want to consider using to test code before deploying it to hardware, or if you don't have access to the Arduino kit. \url{https://wokwi.com/}}

You will all be required to purchase an Arduino learning kit. 
It is highly recommended you purchase the Arduino Mega complete starter kit from ELEGOO as it has all of the components necessary for the course, as well as a multitude of projects for your own education.
Additionally, the expansive IO of the Arduino Mega will make certain projects easier for you through the course and give you larger amounts of program storage and memory for more complex projects.

Most of the simpler discreet parts will be discussed ad nauseam in later sections of these notes.
Therefore, they will be skipped in this section.
Below are some of the more unique parts of the Arduino Mega kit and what they can do.
    
    \subsection*{Microcontroller}
    The Arduino Mega uses an ATmega2560 microcontroller to execute programs and interface with a wide variety of inputs and outputs.
    \marginnote{More information on the Arduino Mega can be found the Arduino website - \url{https://www.arduino.cc/en/Guide/ArduinoMega2560/}}
    This chip has:
    \begin{itemize}
        \item 86 programmable General Purpose Input/Output (GPIO) pins that operate at a 5V TTL logic.
        \item 16 10-bit analog inputs
        \item 2 8-bit counters; 2 16-bit counters
        \item 1 Serial Peripheral Interface (SPI) bus
        \item 4 Universal Synchronous/Asynchronous Receive/Transmit (USART) busses
        \item 256 KB of flash memory for program storage
        \item 8 KB of SRAM for program memory
        \item 8 KB of EEPROM for long term, fast access storage
    \end{itemize}

    The ATmega2560 has been widely adopted by the Arduino and maker community so there is rich and mature development support for the chip.
    In this course, you will be using the Arduino IDE (or Visual Studio Code) to program the microcontroller. 
    Normally, flashing code to a microcontroller is not a streamlined process, but thanks to the hard work on the Arduino Foundation and a globe-spanning community, all that is required to go from code to a blinking light is a USB cable and the push of a button.

    \begin{figure*}[h!]
        \includegraphics[height=6in]{learning_materials/arduino_kit/Arduino-Mega-Pinout.jpg}
        \caption[Arduino Mega Pinout]{The pinout for the Arduino Mega. Retrieved from \href{https://www.electronicshub.org/wp-content/uploads/2021/01/Arduino-Mega-Pinout.jpg}{Electronics Hub}}
        \labfig{arduino_mega_pinout}
    \end{figure*}

    \pagebreak % Force material past the previous section
    \subsection*{MAX7219 LED Matrix Module}
    The MAX7219 is a common cathode LED driver IC that has a four wire serial interface compatible with all microcontrollers.
    The IC is capable of driving up to 64 LEDs making it perfect for driving dot matrix displays and 7-segment displays.
    It also has a built-in BCD decoder and 64-byte static RAM which makes it very easy to display numbers, letters, or symbols on a dot matrix or 7-segment display.

    \begin{figure}[h!]
        \includegraphics[]{learning_materials/arduino_kit/MAX7219-led-matrix-pin-out.png}
        \caption[LED Matrix Pinout]{The pinout for the 8x8 LED dot matrix present in the Arduino Mega Starter Kit. 
        Retrieved from \href{https://microcontrollerslab.com/wp-content/uploads/2021/09/MAX7219-led-matrix-pin-out.jpg?ezimgfmt=ng:webp/ngcb1}{Microcontrollers Lab}}
        \labfig{led_matrix_pinout}
    \end{figure}

    \marginnote{Additional information on the MAX7219 can be found here: \url{https://microcontrollerslab.com/max7219-8-digit-led-display-driver/}}

    For this particular kit, the MAX7219 drives an LED dot matrix with 8 rows and 8 columns (64 LEDs total). 
    Each LED is addressable by its particular row and column number.
    As seen in Figure \ref{fig:led_matrix_schematic}, the positive terminal of the LED "dot" is connected to a row pin, and the negative terminal of the dot is connected to a column pin.
    By setting a particular row to a positive voltage and a particular column to ground, we can turn on a dot.
    This matrix layout is a form of multiplexing and allows a microcontroller to drive 64 LEDs with only 16 pins!

    \begin{figure}[b!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/led-matrix.png}
        \caption[LED Matrix Schematic]{The schematic for the 8x8 LED dot matrix present in the Arduino Mega Starter Kit. 
        Retrieved from \href{https://microcontrollerslab.com/wp-content/uploads/2016/11/led-matrix.jpg?ezimgfmt=ng:webp/ngcb1}{Microcontrollers Lab}}
        \labfig{led_matrix_schematic}
    \end{figure}

    However, 16 pins is still a substantial amount for an embedded platform and computing the logic for which LEDs to turn on/off for a specific symbol wastes valuable compute cycles.
    It is much more efficient for us to use a dedicated IC like the MAX7219 to handle driving the matrix for us. 
    The IC can use its built-in serial decoder to drive all 64 LEDs from 4 pins on the microcontroller.
    It also handles all of the logic for displaying specific symbols, relieving the microcontroller from additional calculations.
    Since the MAX7219 sole purpose is to drive LED displays, it can also run much faster allowing programs to display text that smoothly scrolls across the matrix with minimal interruption.
    
    The MAX7219 serial bus also supports daisy chaining so multiple LED matrices can be connected in series to make a larger overall display.\sidenote{This does come at the cost of increasing input delay with every module. Too many modules chained together can have undesirable performance.}

    \subsection*{DS3231 Real-time Clock Module}
    The DS3231 is a sophisticated real-time clock module that maintains a high time keeping accuracy over a long period of time and a range of temperatures.
    You can communicate with the DS3231 over the I2C bus which makes it extremely simple to get up and running with most microcontrollers.
    It also has a low power draw so it can be powered by a dedicated battery to ensure that projects have an accurate time keeper for data-logging, wake up interrupts, etc.

    Once you initialize the date and time on the module, you will be able to routinely get the day, month, year, day of the week, hour, minute, and second from the IC over I2C. So long as it has power, it will provide you the time.

    \begin{marginfigure}[-2in]
        \includegraphics[]{learning_materials/arduino_kit/ds3231-rtc.jpg}
        \caption[DS3231 RTC Module]{The DS3231 RTC module from the Arduino kit. 
        Retreived from \href{https://alltopnotch.co.uk/wp-content/uploads/imported/9/RTC-Real-Time-Clock-DS3231-I2C-AT24C32-Board-Module-Arduino-ARM-PIC-UK-Seller-361515587149-4.JPG}
        {All Top Notch}}
        \labfig{ds3231_rtc}
    \end{marginfigure}

    \subsection*{Matrix Keypad}
    The ELEGOO kit comes with a 4x4 matrix keypad with 16 individual keys.
    Much like the LED dot matrix, the keypad multiplexes the 16 buttons into four row pins, and four column pins, as shown in Figure \ref{fig:matrix_keypad}.
    In order to use the keypad, you will "scan" the matrix by connecting each column pin to an input with a pull-up resistor, and each row to an output pin.
    By incrementally setting each row pin to low, and checking the input of each column pin, you can determine which button has been pressed.
    For example, if you are checking the second row of buttons by setting that pin to low and the third column pin is also low, than the button in position (2,3) (normally `6') is pressed.

    \begin{figure}[h!]
        \includegraphics[height=2.5in]{learning_materials/arduino_kit/4x4-matrix-keypad.png}
        \caption[4x4 Matrix Keypad]{The pinout and schematic for the 4x4 matrix keypad included in the Arduino starter kit. 
        Retrieved from \href{https://dhaneshablogs.blogspot.com/2019/08/interfacing-4x4-matrix-keypad-with.html}
        {Dhanesha Blogs}}
        \labfig{matrix_keypad}
    \end{figure}

    \subsection*{PIR Motion Sensor}
    Passive Infrared (PIR) motion sensors detect levels of infrared radiation in their field of view.
    Inside a plastic bubble housing is a crystal that is sensitive to IR radiation and is split into two halves.
    If one half of the crystal detects a different level of IR radiation than the other, the PIR driver IC will trigger a change on the interrupt line.
    This allows a microcontroller to do basic human sensing applications for monitoring foot traffic in an area, or if someone has entered/left a room.
    Additionally, the PIR sensor has some potentiometers that allow users to tweak the sensitivity of the module and the time delay between triggers.

    \begin{figure}[h!]
        \includegraphics[height=2.5in]{learning_materials/arduino_kit/pir_sensor.jpg}
        \caption[PIR Sensor]{The PIR sensor module included in the Arduino kit. 
        Retreived from \href{https://www.tutorialspoint.com/arduino/arduino_pir_sensor.htm}
        {Tutorials Point}}
        \labfig{matrix_keypad}
    \end{figure}

    \subsection*{IR Receiver}
    The IR receiver operates with the same physical principles as the PIR motion sensor, but has much simpler circuitry.
    Inside a small housing is a crystal that is sensitive to IR radiation.
    When the crystal is excited, it creates an electrical signal that can be read by a microcontroller on the output pin.
    All IR remotes (including the one in your Arduino kit) encode your button presses as flashes of IR light.
    When the IR receiver "sees" these flashes, it will convert them to an electrical signal with roughly the same timing as the remote output.
    This allows you to communicate with your microcontroller over light waves and signal it for different actions or functions.

    This is the same exact way older TVs and AV receivers and DVD players function. 
    Pressing a button on your remote would send an encoded signal to turn up or down the volume, change the channel, or fast forward a movie.
    Universal remotes simply were able to switch between different encoding schema for different devices.
    Can you decode the messages your TV receives?

    \begin{marginfigure}[-2.5in]
        \includegraphics[]{learning_materials/arduino_kit/ir-receiver.jpg}
        \caption[IR Receiver]{The IR receiver module included in the Arduino kit. 
        Retreived from \href{https://www.circuitbasics.com/arduino-ir-remote-receiver-tutorial/}
        {Circuit Basics}}
        \labfig{ir_receiver}
    \end{marginfigure}

    \subsection*{LCD Screen}
    \marginnote{You will become very familiar with this module in \hyperref[ch:p4_accelerometer_display]{Project 4}!}
    You kit comes with a neat module called the LCD 1602 Display.
    It can display text, images or icons in a 16-character by 2-column matrix.
    LCD stands for Liquid Crystal Display which is a technology that most screens in the world use. 
    Each character in the display is comprised of a 5x8 matrix of pixels.
    A driver IC applies an electric field to each of those specific pixels, polarizing the liquid crystal masking filter above it.
    This allows light from the backlight to be filtered through so you can see the message written on the display.
    The data used to drive the LCD is sent from the Arduino over the parallel bus which sends multiple bytes over multiple lines \textit{in parallel} to increase overall throughput.

    \begin{figure}[h!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/lcd1602.png}
        \caption[LCD Module]{The LCD1602 module included with the Arduino kit. 
        Retrieved from \href{https://www.orientdisplay.com/wp-content/uploads/2020/08/AMC1602AR-B-B6WTDW-I2C-1.jpg}
        {Orient Display}}
        \labfig{lcd_module}
    \end{figure}

    % \pagebreak % Force material past the previous section
    \subsection*{Joystick}
    The joystick is a ubiquitous human input device (HID).
    If you have every played with a game controller, you have used a joystick.
    It consists of two potentiometers: one on the x-axis and one on the y-axis, and a push button.
    These potentiometers are spring loaded to return to the center (neutral) position when no force is acting on the stick.\sidenote{You can learn more about potentiometers and joysticks in the \hl{RESISTOR SECTIONS}}
    When you push the stick forwards or backwards, the y-axis potentiometer will change the voltage on the output pin, allowing the Arduino to detect movement.
    Same goes for left and right motion on the x-axis.
    Pushing the stick in will press the built-in button, adding another input method to the Arduino.

    \begin{marginfigure}[-2in]
        \includegraphics[]{learning_materials/arduino_kit/joystick.png}
        \caption[Joystick]{The PS2-style dual axis joystick included with the Arduino Kit. 
        Retrieved from \href{https://www.orientdisplay.com/wp-content/uploads/2020/08/AMC1602AR-B-B6WTDW-I2C-1.jpg}
        {DH Gate}}
        \labfig{lcd_module}
    \end{marginfigure}

    \subsection*{Ultrasonic Distance Sensor}
    The ultrasonic distance sensor included with your kit is a time-of-flight based tool for detecting the proximity of objects.
    Much like how a bat or dolphin uses echolocation, this sensor emits a pulse of sound for a certain duration at a certain frequency.
    The sound is emitted from the transmitter, reflects off an object, and is heard by the receiver.
    By measuring the time between the pulse being sent out and the reflected pulse being received, and knowing the speed of sound through air, we can determine the distance to an object.
    
    \begin{marginfigure}[-1.5in]
        \includegraphics[]{learning_materials/arduino_kit/ultrasonic-sensor.jpg}
        \caption[Ultrasonic Sensor]{The ultrasonic distance sensor included with the Arduino Kit. 
        Retrieved from \href{https://alexnld.com/wp-content/uploads/2017/12/DIY4002_1.jpg}
        {Alexnld}}
        \labfig{ultrasonic_sensor}
    \end{marginfigure}

    \subsection*{Sound Detection Module}
    The KY-038 microphone module is a capacitive microphone that is sensitive to frequencies from 50-10k Hz and has an amplification circuit on-board.
    This microphone converts sound pressure waves into an electrical signal that the Arduino can read for various tasks.
    By fiddling with the sound level potentiometer on the module, a threshold sound amplitude can be controlled.
    When the microphone detects a sound above the set threshold, it will output a digital signal on an output pin.
    Additionally, there is an analog output pin which the Arduino can use to detect the amplified sound waveforms captured by the microphone.
    The pinout for this module is shown below.

    \begin{figure}[h!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/sound-detection-module.png}
        \caption[Sound Detection Module]{The KY-038 sound detection module included with the Arduino Kit. 
        Retrieved from \href{https://microcontrollerslab.com/ky-038-microphone-sound-sensor-module-arduino-tutorial/}
        {Microcontrollers Lab}}
        \labfig{sound_module}
    \end{figure}

    \subsection*{ULN2003 Motor Driver Board}
    The ULN2003 stepper driver IC is a common motor driver module for stepper motors. \sidenote{You can learn more about stepper motors and how to drive them in the \hl{ACTUATORS SECTION}}
    This driver uses 4-inputs to determine what sequence to drive the stepper motor poles.
    By connecting the Arduino to these inputs and setting them high or low in a certain sequence, the ULN2003 module will "step" the motor, rotating it a precise and known amount.
    This can give you very precise control over rotational and linear motion.
    There are also a multitude of libraries available to help simplify working with this module and making precise movements.

    \begin{figure}[h!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/uln2003-module-pinout.jpg}
        \caption[Motor Driver]{The ULN2003 motor driver board included with the Arduino Kit. 
        Retrieved from \href{https://arduinogetstarted.com/images/tutorial/uln2003-module-pinout.jpg}
        {Arduino Get Started}}
        \labfig{motor_driver}
    \end{figure}

    \subsection*{DHT-11 Sensor}
    The DHT-11 sensor module features a humidity and temperature sensor combined into a signal package with a calibrated digital output.
    The temperature sensor is an Negative Temperature Coefficient (NTC)-type that reduces its resistance as temperature increases.
    The humidity sensor is a resistive-type component that changes its resistance based on the ambient humidity.
    These sensors are connected to a small dedicated microcontroller through a amplifier network.
    The microcontroller reads in the sensor values and outputs the data over a single wire digital interface.
    Your Arduino can connect to that interface and get the ambient temperature and humidity using a multitude of libraries.
    
    \begin{figure}[h!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/DHT11-Sensor-Module-Parts.png}
        \caption[DHT-11 Sensor]{The DHT-11 temperature and humidity sensor included with the Arduino Kit. 
        Retrieved from \href{https://circuitdigest.com/sites/default/files/inlineimages/u4/DHT11-Sensor-Module-Parts.png}
        {Circuit Digest}}
        \labfig{dht11_sensor}
    \end{figure}

    \subsection*{Water Level Sensor}
    The water level sensor has a series of ten traces exposed on its PCB; five are power traces, five are sense traces.
    These traces are interlaced such that they are not connected until they are submerged in water and bridged together.
    As the water level increases, more sense traces are connected to more power traces and thus, the overall resistance of the circuit is decreased.
    This resistance is inversely proportional to the water level (i.e. as the water level increases, the resistance wll decrease).
    By measuring the voltage across the sensing pin and ground, we can correlate the water level to the voltage reading, much like we would with a potentiometer.
    One caveat though is that constantly powering the sensor while it is submerged will dramatically increase the galvanic corrosion and reduce the sensor's lifespan.
    Therefore the positive voltage pin should only be driven high when a reading is actively being taken.

    \begin{figure}[h!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/water-sensor-pinout.jpg}
        \caption[Water Level Sensor]{The water level sensor included with the Arduino Kit. 
        Retrieved from \href{https://arduinogetstarted.com/images/tutorial/water-sensor-pinout.jpg}
        {Arduino Getting Started}}
        \labfig{dht11_sensor}
    \end{figure}

    \subsection*{4-Digit 7-Segment Display}
    \marginnote{You will become very familiar with this module in \hyperref[ch:p3_7seg_counter]{Project 3}!}
    The 4-digit 7-segment display is a series of 7-segment displays connected together in parallel with a common cathode.
    Much like the keypad and LED dot matrices, this module can display different numbers and values based off which lines are turned on or off.
    There are four "digit" lines that are connected to the anode of their respective digit.
    Driving these lines high, while pulling one of the display LEDs low will cause that LED to illuminate.
    For example, to display a "0" in the first digit, you would drive the first digit pin high, and pull the LEDs pins A-F low, illuminating a "0".

    On the Arduino, it can be inconvenient to connect so many data lines, so often, a shift register like the 74HC595 is used to drive the display LEDs, while the Arduino controls which digits are activated.

    \begin{figure}[h!]
        \includegraphics[height=3in]{learning_materials/arduino_kit/4-digit-7-segment-display.png}
        \caption[4-Digit 7-Segment]{The 4-digit 7-segment display included with the Arduino Kit with pinout. 
        Retreived from \href{https://i.ytimg.com/vi/fYAlE1u5rno/maxresdefault.jpg}
        {Make Crate}}
        \labfig{4digit_7seg}
    \end{figure}

    \begin{figure*}[b]
        \includegraphics[height=3in]{learning_materials/arduino_kit/arduino-4-digit-7-segment-insides.png}
        \caption[4-Digit 7-Segment Schematic]{The inside schematic of the 4-digit 7-segment display. 
        Retreived from \href{https://lh6.googleusercontent.com/-UVNbhMgaoc4/Thh-bH7d5zI/AAAAAAAAAEQ/FphoqjmYsVg/s800/arduino-4-digit-7-segment-insides.png}
        {All About EE}}
        \labfig{4digit_7seg_sch}
    \end{figure*}
