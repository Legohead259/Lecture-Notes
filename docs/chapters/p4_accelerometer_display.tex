% ===========================================
% Project 4: Accelerometer and LCD Display
% Written by: Braidan Duffy
%
% Date: 05/30/2022
% Last Revision: 07/27/2022
% ============================================

\chapter{Project 4: MPU6050 Accelerometer and LCD Display}
\labch{p4_accelerometer_display}

\section*{Overview} \labsec{p4_overview}
This project will introduce to you the concepts of reading sensor values and storing them in a packet, and displaying those values on an LCD display. 
You will read the accelerometer and gyroscope readings from the MPU6050 sensor (also referred to as the GY-521 module) and store them in an internal structured data packet for reporting to the LCD module.
Your LCD1602 module will have several different pages: one page will show the accelerometer values, another will show the gyroscope values, a third will show roll and pitch data, and others will show any additional information you desire.
\marginnote{See the \hyperref[sec:p4_extra_credit]{Extra Credit} section for more details.}
A button will be used to cycle between the different pages and a buzzer will be used to provide auditory feedback on every press.

\section*{Graduate Students} \labsec{p4_graduate_students}
You will have some additional work for this project. 
Since an accelerometer provides accelerations, it will be your task to extrapolate (integrate) velocity and position as well as the other tasks outline above.
You will be required to store this information in your storage packet and display the velocity and position values on separate pages on the LCD module.
Since the MPU6050 module lacks a magnetometer, it will also be your task to integrate the heading angle and save it to the telemetry packet.
You will also program the button to act as position and heading reset after you hold the button down for a certain amount of time.

\section*{Requirements} \labsec{p4_requirements}
For completion of this project, you must demonstrate the following:
\begin{outline}
    \1 Successful wiring of the MPU6050 IMU, LCD1602 module, piezoelectric buzzer, and button input (with appropriate debounce filtering)
    \1 Reading and calculating a variety of values from the MPU6050 sensor and storing them in a telemetry packet.
        \2 Acceleration X,
        \2 Acceleration Y,
        \2 Acceleration Z,
        \2 Gyroscope X,
        \2 Gyroscope Y,
        \2 Gyroscope Z,
        \2 Roll,
        \2 Pitch
    \1 Display the values on distinct pages on the LCD display with appropriate labels and units
        \2 Page 1: Acceleration values
        \2 Page 2: Gyroscope values
        \2 Page 3: Orientation values
    \1 Use a button tied to an interrupt service routine on the Arduino to cycle between the different LCD pages
    \2 Use a buzzer to provide auditory feedback on each button press 
\end{outline}

\section*{Submission}
You will be required to submit the following on Canvas:
\begin{outline}
    \1 a video of the project working with narration of what is occurring
    \1 a well-organized and documented schematic of the project setup
    \1 the source code file
\end{outline}
Please package all of these items into a compressed (zipped) folder and upload them to Canvas.

\section*{Grading} \labsec{p4_grading}
You will be graded on the following criteria:
\begin{table}[h!]
    \begin{tabular}{l | c}
        \toprule
        Criterion & Points \\

        \midrule
        Efficacy & 50 \\
        Well organized and neat schematic & 20 \\
        Well organized and neat source code & 30 \\
        Extra Credit Challenge 1 \footnotemark & 25 \\
        Extra Credit Challenge 2 & 25 \\
        Extra Credit Challenge 3 & 25 \\
        Extra Credit Challenge 4 & 25 \\

        \bottomrule
    \end{tabular}
\end{table}
\footnotetext{Graduate students: this will count towards your normal score}

\section*{Extra Credit} \labsec{p4_extra_credit}
There exists many opportunities for extra credit on this assignment. 
Ultimately, this is your chance to really explore and learn how to interact with sensors on a low level and gain an in-depth understanding of the relationship between microcontrollers and sensors.
To that end, it is highly encouraged to pursue the following challenges and earn as many points as possible.
A successful demonstration of \emph{all} of the challenges below will earn you \textbf{an exemption from the midterm exam}.
If you fail to finish all the challenges, the appropriate amount of points will still be given to you and used as standard extra credit for this assignment.

In your submission, please include a note of which challenges you have completed and videos of the challenge working. 
You will also need to include source code highlighting the specific challenge sections.
\emph{If it is not clear where your challenge-specific code is, it may not be counted.}

    \subsection*{Challenge 1: Sensor Fusion - Attitude and Heading Reference System}
    \marginnote{\textbf{Note:} This challenge is \emph{mandatory} for graduate students.}
    In this challenge, you are tasked with combining the accelerometer and gyroscope readings from the MPU6050 into a unified AHRS.
    There are a multitude of different ways to accomplish this task, but at the end, you should be able to store the values into a telemetry packet and display them on separate pages on your LCD module.
    You will be required to capture and store:

    \begin{itemize}
        \item Acceleration (X, Y, Z)
        \item Gyroscope (X, Y, Z)
        \item Orientation (Roll, Pitch, Yaw [heading])
        \item Velocity (X, Y, Z)
        \item Displacement (X, Y, Z)
    \end{itemize}

    The button used to change the display page will also act as a position and velocity reset when held for a certain amount of time.
    Keep in mind, that the coming challenges will build upon this one, so make sure you build and format your code such that new blocks can be easily added!

    \textbf{FOR CREDIT:} in your submission video scroll through the different pages of the LCD module and show that you are, in fact, capturing the appropriate data.
    When you reach the position page, reset the position values back to 0 after a couple of seconds.

    \subsection*{Challenge 2: Kalman Filtering}
    \marginnote{For information, consult the lecture notes Chapter \ref{ch:data_processing}, Section \ref{sec:kalman_filter}, 
    \href{http://blog.tkjelectronics.dk/2012/09/a-practical-approach-to-kalman-filter-and-how-to-implement-it/}{TJKElectronics' excellent brief}, 
    \href{https://github.com/TKJElectronics/Example-Sketch-for-IMU-including-Kalman-filter/tree/master/IMU}{TJKElectronics' example code}, and 
    \href{https://www.kalmanfilter.net/default.aspx}{This excellent tutorial} (focus on the 1-dimensional application for now).}

    In this section we are going to expand upon the AHRS challenge and try to clean up the data by using a Kalman filter to improve the estimations of the "real" orientation.
    You will construct three 1-dimensional Kalman filters that will predict the board's current orientation in Euler angles.
    Again, the telemetry packet will be updated with these values and displayed on the LCD module.

    \textbf{FOR CREDIT:} you must submit a capture of a plot created from your data that shows either roll, pitch, yaw values.
    One line must be the method you used previously, and one line must be the Kalman-filtered estimate.
    Quickly discuss the results in your submission.

    \subsection*{Challenge 3: Removing Gravity}
    For this challenge, we will convert the acceleration signals into linear acceleration, put that information into the telemetry packet, and display it on a separate page of the LCD module.
    For this challenge, it is strongly recommended to use a quaternion rotation as this method is immune to \href{https://www.youtube.com/watch?v=zc8b2Jo7mno}{gimbal lock} - a phenomenon where rotations require additional euler transformations at certain points.

    To assist you, the code to convert from Euler angles to Quaternion is below:
    \begin{lstlisting}[linewidth=1.5\textwidth, language=C++]
struct Quaternion
{
    double w, x, y, z;
};

// yaw (Z), pitch (Y), roll (X)
Quaternion ToQuaternion(double yaw, double pitch, double roll)
{
    // Abbreviations for the various angular functions
    double cy = cos(yaw * 0.5);
    double sy = sin(yaw * 0.5);
    double cp = cos(pitch * 0.5);
    double sp = sin(pitch * 0.5);
    double cr = cos(roll * 0.5);
    double sr = sin(roll * 0.5);

    Quaternion q;
    q.w = cr * cp * cy + sr * sp * sy;
    q.x = sr * cp * cy - cr * sp * sy;
    q.y = cr * sp * cy + sr * cp * sy;
    q.z = cr * cp * sy - sr * sp * cy;

    return q;
}
    \end{lstlisting}

    From there, you will define a Quaternion vector for gravity defined in the North, East, Down (NED) reference frame.
    \marginnote{\emph{Hint:} it's just a normal gravitational acceleration vector with another term for the 'w' component of the Quaternion.}
    Then, you will rotate the gravity quaternion from the NED reference frame to the body reference frame using:
    
    \begin{equation*}
        Q_{g,b} = Q_b^{-1} * Q_{g,NED} * Q_b
    \end{equation*}

    Finally, subtract the X,Y,Z components of the rotated Quaternion vector for gravity from the recorded body accelerations and you will have linear acceleration! \emph{Easy right!?}
    
    As always, display these values on a new page of the LCD module!
    
    \subsection*{Challenge 4: MPU6050 Motion Detect Interrupt}
    The interrupt pin on the MPU6050 can be configured to serve as a motion detection trigger.
    This challenge's task will be to put the Arduino into a sleep mode after the initialization and use the motion detection interrupt to wake the Arduino up and read sensor data for a defined period of time before going back to sleep.

    \textbf{FOR CREDIT:} In your submission video, demonstrate the Arduino not capturing any data (asleep), then you jolting the Arduino awake by moving the accelerometer, and the values changing on the LCD module.
    After a set time, these readings should stop updating as the Arduino goes back to sleep.
