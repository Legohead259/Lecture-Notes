% ===========================================
% Digital Logic
% Written by: Braidan Duffy
%
% Date: 07/06/2022
% Last Revision: 07/25/2022
% ============================================

\setchapterstyle{kao}
\chapter{Digital Electronics}
\setchapterpreamble[u]{\margintoc}
\labch{digital_electronics}

Computers have existed in some fashion or another for millennia.
The ancient antikythera mechanism was a hand-powered computer that predicted the position of astronomical bodies throughout the year.
Mathematicians in the 18th and 19th centuries used complicated machines and mechanisms to run calculus and trigonometric calculations at speeds way faster than possible by humans by hand.
Then, in the mid-1940's nations used analog computers to compute the trajectories of ballistic projectiles and free falling bombs.
Today, analog computers are still used in niche applications, but since the transistor revolution of the 1960's and 1970's, almost every computer in the world has transitioned to digital logic.

\section[Introduction to Binary]{Introduction to Binary}
Digital logic is electrically simple to implement: either current flows (a logical '1') or it does not (a logical '0').
Even better, the circuit required to calculate digital logic can be generalized or reconfigured, depending on the architecture used.
This makes digital logic a far more versatile tool compared to analog computers which can only be made for specific applications.

The fundamentals of computing are above the scope of these notes, but it is still important for engineers to understand the basic logic behind digital computations and know about the 1's and 0's that dictate our modern lifestyles

\paragraph*{What is Binary?} Binary is the representation of the state of an object.
As the latin prefix implies, there are two states represented by binary: on (logical '1') or off (logical '0').
A lightbulb is a good example of a binary object - it is either on, lighting up a room, or off, leaving the room in darkness.

Binary is fundamentally a numbering system, much like the arabic numerals we use in our day-to-day lives.
Arabic numerals are in Base10, meaning we comprehend counting in multiples of 10 using the digits 0-9. For example:
\begin{align*}
    20     &= 10*2 \\
    450    &= 4*10*10 + 5*10 \\
    245683 &= 2*10^5 + 4*10^4 + 5*10^3 + 6*10^2 + 8*10^1 + 3*10^0
\end{align*}

Binary is counted in Base2, meaning everything is counted in multiples of 2 using the digits 0 and 1. Using the same example as before:
\begin{align*}
    20     &= 2^4 + 2^2 \\
    450    &= 2^8 + 2^7 + 2^6 + 0^5 + 0^4 + 0^3 + 0^2 + 2^1 + 0^0 \\
    245683 &= 2^{17} + 2^{16} + 2^{15} + 2^{13} + 2^{12} + 2^{11} + 2^{10} + 2^9 + 2^8 + 2^7 + 2^5 + 2^4 + 2^1 + 2^0
\end{align*}
        
While this is inefficient for a human to understand its meaning, a computer can quickly transform this on/off pattern of electrons into numbers for calculations.

Binary numbers are broken down into three groupings: bits (one number), nibbles (four bits), and bytes (two nibbles or eight bits). 
The groupings are extremely important as the order and number of the bits in a binary representation dictate the number or logical input used in the calculation.
Each bit is indexed starting from 0, as shown in \hl{FIGURE} and goes from the Least Significant Bit (LSB) at index 0, to the Most Significant Bit (MSB) at the furthest index. 
\sidenote{These indecies get their names because of how they affect the binary number when changed. 
The LSB only changes the numerical value by 1.
The MSB, on the other hand, can change the value by upto an infinite value, depending on how many bits are present in the binary number}

\begin{figure*}
    \labfig{byte_breakdown}
    \includegraphics[height=2.5in]{digital_logic/bit-breakdown.png}
    \caption[Byte Breakdown]{Breakdown of a byte from the largest unit, to the smallest, with indexing.}
\end{figure*}

% \pagelayout{wide} % Remove margins

\begin{example}
    Let's take a look at a practical demonstration of binary using your Arduino kit.
    You will need:
    \begin{itemize}
        \item 1 x Red LED
        \item 1 x button
        \item 1 x 220 $\Omega$ resistor
        \item 2 x Male-to-Male jumper wires
    \end{itemize}

    Wire these components to a breadboard like so:
    % \begin{figure}
        
    % \end{figure}

    The dfault state for this system should be active high, meaning the LED will be off when the button is not pressed - a logical 0.
    When you press the button, you push the system to the high state and turn on the LED - a logical 1!
\end{example}

% \pagelayout{margin} % Restore margins

    \subsection{Binary Arithmetic}
    Much like our beloved arabic numerals, binary numbers can be added, subtracted, multiplied, and divided.

    \paragraph*{Addition} Adding binary numbers is straight-forward.
    Simply stack the numbers you wish to add on top of each other, ensuring the indices align.
    Note, binary addition is commutative, meaning the number order does not matter, so long as the indices are aligned.
    Then, for each index, add the numbers together.
    If the result is greater than 1, then set the result of the index addition to 0 and carry a '1' over to the next index.
    Repeat until you have calculated the last index!

    \begin{example}[Adding binary numbers]
        Let's add $7_{10}$ ($0111_2$) and $11_{10}$ ($1011_2$):
        \begin{center}
            \begin{tabular}{ccccc}
                $^1$  & $0^1$ & $1^1$ & $1^1$ & $1$ \\
                +     & 1     & 0     & 1     & 1 \\
                \hline
                1     & 0     & 0     & 1     & 0 \\
            \end{tabular}
        \end{center}
    \end{example}

    \paragraph*{Subtraction} Subtracting binary numbers is simply the same algorithm for Base10 numbers.
    Starting at the LSB, subtract the two numbers index-by-index.
    If a case arises, when the subtrahend \sidenote{bottom number} has a larger number than the same index in the minuend \sidenote{top number}, borrow a '1' from the next index.
    If you are are unable to borrow a '1', grab one from the next index until you can get a '1' to bring back.
    When you bring a '1' back, then perform the subtraction.
    Repeat this process until you have calculated the last index.
    
    \begin{example}[Subtracting binary numbers]
        Let's subtract $24_{10}$ ($11000_2$) and $7_{10}$ ($111_2$):
        \begin{center}
            \begin{tabular}{cccccc}
                  & 1 & $1^0$ & ${0^{10}}^1$ & ${0^{10}}^1$ & ${0^{10}}^1$  \\
                - & 0 & 0     & 1            & 1            & 1             \\
                \hline
                  & 1 & 0     & 0            & 0            & 1             \\
            \end{tabular}
        \end{center}
    \end{example}

    \begin{kaobox}[frametitle=Aside: 2's Complement Method]
        The above method is easy for humans to understand, but computationally expensive. 
        For operations that require borrowing, many repetitive borrow operations are performed, wasting CPU cycles.
        Instead, computers use a complement method to simplify the subtraction operation and increase performance.

        Here, we are going to perform the same calculation as before. Begin by aligning the two numbers as previously, "padding" \sidenote{adding leading zeroes, as necessary} both numbers so they are the same length.
        
        \begin{center}
            \begin{tabular}{cccccc}
                  & 1 & 1 & 0 & 0 & 0 \\
                - & 0 & 0 & 1 & 1 & 1 \\
                \hline
            \end{tabular}
        \end{center}

        Then, switch all of the bits in the subtrahend. In this case, 00111 becomes 11000. \sidenote{What is occuring here is known as the 1's complement as we are subtracting '1' from each bit in the number. This only works in binary}
        Then, we are going to add 1 to the switched term:
        \begin{equation*}
            11000 + 1 = 11001
        \end{equation*}
        We are then going to change the math problem from subtraction to addition and add the original minuend and the new, switched subtrahend.

        \begin{center}
            \begin{tabular}{cccccc}
                  & 1 & 1 & 0 & 0 & 0 \\
                + & 1 & 1 & 0 & 0 & 1 \\
                \hline
                \cancel{1} & 1 & 0 & 0 & 0 & 1 \\
            \end{tabular}
        \end{center}

        To finish the algorithm, remove the MSB from the resultant. 
        You can compare this number to the previous calculation and notice that the final result is the same, depite the radically different method.
        Even though the complement method is unintuitive for humans to understand, it is vastly superior for a computer to execute as the number of required operations is dramatically smaller than the original method, even with larger values.
    \end{kaobox}

    \paragraph*{Multiplication} Binary multiplication occurs in the same order as decimal long multiplication.
    It is a commutative process, like addition, but in order to reduce the number of steps required, it is recommended that the number with the least amount of bits is the multiplicand \sidenote{bottom number} and the other factor is the multiplier \sidenote{top number}.
    For the operation, you will multiply the multiplier by each bit of the multiplicand to calculate an intermediate value.
    With every new index of the multiplicand, shift the resulting product over one bit until you have calculated the intermediate product for the last index of the multiplicand.
    Simply add all the intermediate products together to calculate the final result.

    \begin{example}[Multiplying binary numbers]
        Let's multiply $14_{10}$ ($1110_2$) and $3_{10}$ ($0011_2$):
        \begin{center}
            \begin{tabular}{cccccccc}
                  &   &   & 1 & 1 & 1 & 0 \\
                  &   & * & 0 & 0 & 1 & 1 \\
                \hline
                  &   &   & 1 & 1 & 1 & 0 \\
                  &   & 1 & 1 & 1 & 0 &   \\
                  & 0 & 0 & 0 & 0 &   &   \\
                0 & 0 & 0 & 0 &   &   &   \\
                \hline
                0 & 1 & 0 & 1 & 0 & 1 & 0 \\  
            \end{tabular}
        \end{center}
        This leaves us with the answer to the life, the universe, and everything: $0101010_2$ ($42_{10}$).
    \end{example}

    \paragraph*{Division} Binary division works exactly like decimal long division.
    You start with a dividend within the division operator and a divisor operating on it.
    Compare the divisor to the first digit of the dividend; if the divisor is larger, than a '0' is placed above the first index of the dividend, if it is smaller, than a one goes there.
    If the latter case occurs, subtract the section of the dividend from the dividend and continue the dividing operation with this new value.

    \begin{example}[Dividing binary numbers]
        Let's divide $69_{10}$ ($0100 0101_2$) by $3_{10}$ ($0011_2$):
        \[
        \begin{array}{ rr@{} >{\color{red}}c@{}*{6}{c@{\mkern2mu}} }
            & 00010111 & & & &  &  \\ \cmidrule[0.6pt](l{-0.385em}){2-8}\\[-16.9pt]
            0011\;\rlap{\Large)} & 01000101 & & & & & &  \\
            & -11~~~~~~~~~ & & & & & &  \\ 
            \cmidrule(l{1ex}){2-4}
            & 101~~~~~\\
            & -11~~~~~\\ 
            \cmidrule(l{1ex}){2-4}
            & 0100~~~ \\
            & -11~~~ \\
            \cmidrule(l{1ex}){2-4}
            & 11 \\
            & -11 \\
            \cmidrule(l{1ex}){2-4}
            & 0
        \end{array}
        \]
        This is the exact same operation performed in Base10 long division, just everything is in Base2. As you can see, the division leaves us with the correct answer of $10111_2$ ($23_{10}$).
    \end{example}

\section[Logic Gates]{Introduction to Logic Gates}
Logic gates are the building blocks of digital circuits.
An arrangement of gates grants you a specific output for corresponding sets of inputs.
This allows you to "construct" logical equations with visual representations or even physical devices.

    \subsection{Truth Tables}
    It is sometimes inefficient to display a logic flow with a diagram of gates and wires, as shown in \hl{FIGURE}. \todo{Create a figure a bunch of logic gates wired together}.
    So, these flows can be summarized by a truth table as show in in \hl{TABLE}.
    This shows the input parameters and the corresponding outputs.
    These tables can also be helpful in designing the logic diagram when given a problem.

    To setup this table, dedicate a column to each input into your system and have a column for the outputs.
    The LSB will be the column before the output column and the columns will increase in significance to the left.
    Then, for every row in the input columns, start at 0 and alternate between 0 and 1 at a specific interval.
    This interval is dictated by the index (column) of the input bit.
    The LSB will switch every row (0,1,0,1, etc.), the next bit will switch every other row (0,0,1,1, etc.), the next bit will alternate every 4 rows (0,0,0,0,1,1,1,1, etc.), and so on and so forth.
    Then, in your output column, place a 1 where you want the gates to output a logical 1 given a set of inputs.

    For example, lets design an alarm system for a fire place.
    This specific system has four alarms of various types that output a logical 1 when they detect excessive smoke from the fireplace.
    However, these sensors are known to be a little too sensitive and give false positives.
    To prevent the fire department from unnecessarily coming to the rescue, we will not sound the general alarm until two or more sensors detect excessive smoke.
    Therefore, we will construct a truth table like so:

    \begin{table}
        \labtab{truth_table_ex}
        \begin{tabular}[]{c c c c | c}
            \toprule
            Sensor 4 & Sensor 3 & Sensor 2 & Sensor 1 & Output  \\
            \midrule
                0    &    0     &    0     &    0     &    0    \\
                0    &    0     &    0     &    1     &    0    \\
                0    &    0     &    1     &    0     &    0    \\
                0    &    0     &    1     &    1     &    1    \\
                0    &    1     &    0     &    0     &    0    \\
                0    &    1     &    0     &    1     &    1    \\
                0    &    1     &    1     &    0     &    1    \\
                0    &    1     &    1     &    1     &    1    \\
                1    &    0     &    0     &    0     &    0    \\
                1    &    0     &    0     &    1     &    1    \\
                1    &    0     &    1     &    0     &    1    \\
                1    &    0     &    1     &    1     &    1    \\
                1    &    1     &    0     &    0     &    1    \\
                1    &    1     &    0     &    1     &    1    \\
                1    &    1     &    1     &    0     &    1    \\
                1    &    1     &    1     &    1     &    1    \\
            \bottomrule
        \end{tabular}
    \end{table}

    As you can see in Table \ref{tab:truth_table_ex}, for every row where two or more sensors are sending an alarm signal, the output (general alarm) is sending out a signal as well.

    \subsection{Basic Logical Operators}
    In logic, we can write a flow like an equation with a series of operators and notations that determine what outputs will result from given inputs.
    The basic operators are \textbf{AND}, \textbf{OR}, and \textbf{NOT}.
    
    \paragraph*{AND} is a basic logical operation.
    If the input 1 \textit{and} input 2 are both true (logical '1'), then the output is also true.
    Otherwise, the output is false.
    This can be represented by the equation below where $A$ is input 1 and $B$ is input 2.

    \begin{equation*}
        A \cdot B
    \end{equation*}

    And the truth table:
    \begin{table}[h!]
        \labtab{and_truth_table}
        \begin{tabular}{c c | c}
            \toprule
            $A$ & $B$ & $A \cdot B$  \\
            \midrule
             0  &  0  &    0    \\
             0  &  1  &    0    \\
             1  &  0  &    0    \\
             1  &  1  &    1    \\
            \bottomrule
        \end{tabular}
    \end{table}

    Graphically, AND gates are represented by symbols like Figure \ref{fig:and_gate}.
    Wires protrude from the three pins on the gate and "carry" information to and from other gates on the same diagram.
    \begin{figure}[h!]
        \labfig{and_gate}
        \includegraphics[height=1in]{digital_logic/AND_gate.png}
        \caption[AND Gate]{Visual representation of the AND logical operation with two inputs and one output.}
    \end{figure}

    \paragraph*{OR} is another basic logical operation.
    It is the inverse of the AND operation as the logical output will be true when any input is true i.e. input 1 \textit{or} input 2 is true.
    It can be represented by the expression:
    \begin{equation*}
        A + B
    \end{equation*}

    With the truth table:
    \begin{table}[h!]
        \labtab{or_truth_table}
        \begin{tabular}{c c | c}
            \toprule
            $A$ & $B$ & $A+B$  \\
            \midrule
             0  &  0  &   0    \\
             0  &  1  &   1    \\
             1  &  0  &   1    \\
             1  &  1  &   1    \\
            \bottomrule
        \end{tabular}
    \end{table}

    And the visual symbol:
    \begin{figure}[h!]
        \labfig{or_gate}
        \includegraphics[height=1in]{digital_logic/OR_gate.png}
        \caption[OR Gate]{Visual representation of the OR logical operation with two inputs and one output.}
    \end{figure}

    \paragraph*{NOT} is the simplest logical operation of all.
    Simply, whatever input is passed into the NOT gate, the output will be the opposite.
    For example, a logical true input will result in a logical false output, and vice versa.
    This can be represented by the truth table:
    \marginnote{The NOT operation can be represented by either $\bar{A}$ or $!A$ where $!$ is called the "bang" operator.
    The latter operator is widely used within computer programming for the NOT operation, whereas $\bar{A}$ is more used in mathematical and handwritten expressions.}
    
    \begin{table}[h!]
        \labtab{not_truth_table}
        \begin{tabular}{c | c}
            \toprule
            $A$ & $\bar{A}$  \\
            \midrule
             0  &    1    \\
             1  &    0    \\
            \bottomrule
        \end{tabular}
    \end{table}

    And the visual symbol:
    \begin{figure}[h!]
        \labfig{not_gate}
        \includegraphics[height=1in]{digital_logic/NOT_gate.png}
        \caption[NOT Gate]{Visual representation of the NOT logical operation with one input and one output.}
    \end{figure}

    \pagelayout{wide} % Remove margins

    \begin{example}[Basic Logic Gates 1] \label{ex:basic-logic-gates-1}
        Let's practice the basic logic gates.
        We will consider a scenario with four inputs and we only want the logical output to be true when inputs A and B and (C or D) are true.
        We can set this up as the expression:
        \begin{equation*}
            (A \cdot B) + (C + D)
        \end{equation*}

        We will then establish the truth table as:
        \begin{center}
            \begin{tabular}{c c c c | c}
                \toprule
                Input D & Input C & Input B & Input A & Output \\
                \midrule
                    0    &    0     &    0     &    0     &    0    \\
                    0    &    0     &    0     &    1     &    0    \\
                    0    &    0     &    1     &    0     &    0    \\
                    0    &    0     &    1     &    1     &    0    \\
                    0    &    1     &    0     &    0     &    0    \\
                    0    &    1     &    0     &    1     &    0    \\
                    0    &    1     &    1     &    0     &    0    \\
                    0    &    1     &    1     &    1     &    1    \\
                    1    &    0     &    0     &    0     &    0    \\
                    1    &    0     &    0     &    1     &    0    \\
                    1    &    0     &    1     &    0     &    0    \\
                    1    &    0     &    1     &    1     &    1    \\
                    1    &    1     &    0     &    0     &    0    \\
                    1    &    1     &    0     &    1     &    0    \\
                    1    &    1     &    1     &    0     &    0    \\
                    1    &    1     &    1     &    1     &    1    \\
                \bottomrule
            \end{tabular}
        \end{center}
        Here, we can easily see that there are 3 input sets that will allow a logical true output in our scenario.

        Next, we can create a visual representation of this scenario:
        \begin{center}
            \includegraphics[height=2.5in]{digital_logic/BasicGatesEx1.png}
        \end{center}

        While the required input set to get a logical true output is not obvious, it is a little easier to understand the "logic flow" through our scenario and we can test different input ideas and comprehend what is occurring a little easier.

        % \todo{Insert Arduino example!}
    \end{example}

    \begin{example}[Basic Logic Gates 2] \label{ex:basic-logic-gates-2}
        In this scenario, we are going to add a NOT gate and change the output conditions.
        Here we are looking for A and B or not (C or D).
        As before, we set up the scenario as the expression:
        \begin{equation*}
            A \cdot B + \overline{(C + D)}
        \end{equation*}

        We can also build the truth table:
        \begin{center}
            \begin{tabular}{c c c c | c}
                \toprule
                Input D & Input C & Input B & Input A & Output \\
                \midrule
                    0    &    0     &    0     &    0     &    1    \\
                    0    &    0     &    0     &    1     &    1    \\
                    0    &    0     &    1     &    0     &    1    \\
                    0    &    0     &    1     &    1     &    1    \\
                    0    &    1     &    0     &    0     &    0    \\
                    0    &    1     &    0     &    1     &    0    \\
                    0    &    1     &    1     &    0     &    0    \\
                    0    &    1     &    1     &    1     &    1    \\
                    1    &    0     &    0     &    0     &    0    \\
                    1    &    0     &    0     &    1     &    0    \\
                    1    &    0     &    1     &    0     &    0    \\
                    1    &    0     &    1     &    1     &    1    \\
                    1    &    1     &    0     &    0     &    0    \\
                    1    &    1     &    0     &    1     &    0    \\
                    1    &    1     &    1     &    0     &    0    \\
                    1    &    1     &    1     &    1     &    1    \\
                \bottomrule
            \end{tabular}
        \end{center}
        We can see from the table that we have several more conditions that will result in a true output from our expression!

        If we create a diagram of this scenario, we get the following:
        \begin{center}
            \includegraphics[height=2.5in]{digital_logic/BasicGatesEx2.png}
        \end{center}
    \end{example}

    \pagebreak

    \subsubsection*{Arduino Example: Basic Logic Gates}
        Let's practically demonstrate the circuit found in Example \ref{ex:basic-logic-gates-2} using your Arduino Kit!
        
        You will need:
        \begin{itemize}
            \item 4 Buttons
            \item 10 Male-to-Male jumper wires
            \item 1 220-$\Omega$ resistor
            \item 1 Red LED
        \end{itemize}

        Connect these components together in the following circuit:
        \begin{center}
            \includegraphics[]{examples/logic_gates_2_sch.png}
        \end{center}

        Then, we will use the following code to turn on or off the LED according to our button inputs.

        \lstinputlisting[language=C++, firstline=13]{../../src/examples/222-basic_logic_gates_2/222-basic_logic_gates_2.ino}

        Let's break down this code to understand what is occurring.
        First, we define the input pins for our four input buttons: A, B, C, and D.
        The C++ pre-processor command \lstinline[language=C++]{#define} essentially substitutes all calls of the variable name with the value we define in the second parameter.
        Ergo, whenever we have \lstinline[language=C++]{A} passed as a variable, the code will automatically substitute it with the value 2.
        We also create an array of all these pin numbers so we can more easily initialize them later.

        \lstinputlisting[language=C++, linerange={13-20}]{../../src/examples/222-basic_logic_gates_2/222-basic_logic_gates_2.ino}

        Then, we can define \lstinline[language=C++]{setup()} which is the first function the Arduino will call when it boots up.
        Any code that needs to be initialized first needs to be included within this function!
        Here, we have a simple for-loop that iterates through the pin array we defined earlier to initialize them all as \lstinline[language=C++]{INPUT_PULLUP}.
        This particular mode means the Arduino is able to take digital input signals on this pins and pull up these inputs to 5V using internal resistors.
        When we press a button, the pins are pulled low, giving a clear distinction between not pressed and pressed.
        We also set the builtin LED pin to an output so we can turn it on or off.

        \lstinputlisting[language=C++, linerange={22-28}]{../../src/examples/222-basic_logic_gates_2/222-basic_logic_gates_2.ino}

        This finally brings us to \lstinline[language=C++]{loop()} where we implement the actual digital logic.
        We first encounter the if-statement that is our logical expression for this example.
        It is important to note that here, \lstinline[language=C++]{&} is the bitwise AND operator, \lstinline[language=C++]{|} is the bitwise OR operator, and the \lstinline[language=C++]{!} is the bang or bitwise INVERT operator.
        Since this circuit is an active-low configuration, we must invert the readings from the input pins hence \lstinline[language=C++]{!digitalRead(A)}.
        If our logical expression is found to be true, we turn the LED on; otherwise, we turn it off using \lstinline[language=C++]{digitalWrite(LED_BUILTIN, HIGH/LOW)}.
        We then implement a delay of 125 milliseconds which is useful for debouncing the button inputs.

        \lstinputlisting[language=C++, linerange={30-36}]{../../src/examples/222-basic_logic_gates_2/222-basic_logic_gates_2.ino}

    \pagelayout{margin} % Restore margins

    \subsection{Combination Logical Operators}
    As we can see from the previous example, we can combine gates together to change their logical outputs accordingly.
    Adding a NOT gate to the first OR gate gave several more conditions that would make the system output a logical true value.
    However, it can be unnecessarily clumsy to draw a gate immediately followed by a NOT gate, so we can combine them together into a single gate.

    \paragraph*{The NAND operator} is a combination NOT and AND (NOT-AND, NAND) operation. 
    This means the operation outputs a logical true value only when both input 1 \textit{and} input 2 are \textit{not} true.
    \marginnote{For you computer storage afficionados out there, NAND flash memory is one of the predominant architectures for high speed, solid state drives.}
    This can be represented by the expression and truth table below:
    \begin{equation*}
        \overline{(A \cdot B)}
    \end{equation*}

    \begin{table}[h!]
        \labtab{nand_truth_table}
        \begin{tabular}{c c | c}
            \toprule
            $A$ & $B$ & $\overline{(A \cdot B)}$  \\
            \midrule
             0  &  0  &    1    \\
             0  &  1  &    1    \\
             1  &  0  &    1    \\
             1  &  1  &    0    \\
            \bottomrule
        \end{tabular}
    \end{table}

    This gate is graphically represented by the symbol. 
    As you can see, the NAND gate is distinguished from its former identity by the circle at the front of the gate.
    You may also notice that this is the same circle present at the tip of the NOT gate, clearly relating the two.
    \begin{figure}[h!]
        \labfig{nand_gate}
        \includegraphics[height=1in]{digital_logic/NAND_gate.png}
        \caption[NAND Gate]{Visual representation of the NAND logical operation with two inputs and one inverted output.}
    \end{figure}

    \paragraph*{The NOR gate} is a combination NOT and OR (NOT-OR, NOR) operation.
    The bottom symbols in Example \ref{ex:basic-logic-gates-2} can be combined into this single operation to achieve the same effect in a more space-efficient manner.
    This gate has a similar equation to its predecessor, looking like:
    \begin{equation*}
        \overline{(A + B)}
    \end{equation*}

    It is represented by the truth table:
    \begin{table}[h!]
        \labtab{nand_truth_table}
        \begin{tabular}{c c | c}
            \toprule
            $A$ & $B$ & $\overline{(A + B)}$  \\
            \midrule
             0  &  0  &    1    \\
             0  &  1  &    0    \\
             1  &  0  &    0    \\
             1  &  1  &    0    \\
            \bottomrule
        \end{tabular}
    \end{table}

    And the graphical representation below. 
    Again, notice how the only distinguishing factor between a NOR and OR gate is the circle at the tip of the gate.
    \begin{figure}[h!]
        \labfig{nor_gate}
        \includegraphics[height=1in]{digital_logic/NOR_gate.png}
        \caption[NOR Gate]{Visual representation of the NOR logical operation with two inputs and one inverted output.}
    \end{figure}

    \subsection{Advanced Logical Operators}
    Sometimes it is desirable to have some more limited conditions in which an operation will output a logical true.
    
    \paragraph*{The exclusive OR operation} is an operation that only outputs a logical true value when both inputs are different and not the same.
    This gate is represented by the expression:
    \begin{equation*}
        A \oplus B
    \end{equation*}

    This operation can also be shown by the truth table and gate visualization below:
    \begin{table}[h!]
        \labtab{xor_truth_table}
        \begin{tabular}{c c | c}
            \toprule
            $A$ & $B$ & $(A \oplus B)$  \\
            \midrule
             0  &  0  &    0    \\
             
             0  &  1  &    1    \\
             1  &  0  &    1    \\
             1  &  1  &    0    \\
            \bottomrule
        \end{tabular}
        \caption[XOR Gate Truth Table]{The truth table for the XOR gate.}
    \end{table}

    As we can see from the truth table, this operation can be best explained as "\textit{either or, but never both}"

    \begin{figure}[h!]
        \labfig{xor_gate}
        \includegraphics[height=1in]{digital_logic/XOR_gate.png}
        \caption[NOR Gate]{Visual representation of the NOR logical operation with two inputs and one output.}
    \end{figure}

    Note that the visual gate for the exclusive OR is differentiated from its basic counterpart by the additional arc at the back of the gate.

    \paragraph*{The XNOR operation} is just like previous combination operations where we combine the XOR operation with a NOT operation.
    This changes the input requirements for a logical true output to both inputs have to be the same, rather than they have to be different.
    This operation is created by combining multiple operations ike so:
    \begin{equation*}
        \overline{(A+B)} \cdot (A \cdot B)
    \end{equation*}
    And again, these complex combinations can be simplified by adding the $\oplus$ operator an negating it:
    \begin{equation*}
        \overline{(A \oplus B)}
    \end{equation*}

    This results in a truth table and graphical representation shown below:
    \begin{table}[h!]
        \labtab{xnor_truth_table}
        \begin{tabular}{c c | c}
            \toprule
            $A$ & $B$ & $\overline{(A \oplus B)}$  \\
            \midrule
             0  &  0  &    1    \\
             0  &  1  &    0    \\
             1  &  0  &    0    \\
             1  &  1  &    1    \\
            \bottomrule
        \end{tabular}
    \end{table}

    \begin{figure}[h!]
        \labfig{xnor_gate}
        \includegraphics[height=1in]{digital_logic/XNOR_gate.png}
        \caption[XNOR Gate]{Visual representation of the XNOR logical operation with two inputs and one inverted output.}
    \end{figure}

\section{Boolean Algebra}
Boolean algebra can be sed to formalize expressions for logic states.
For these expressions, $A$ and $B$ are binary logical values, meaning they represent either a logical '1' or logical '0'.
$Q$ is representative of the logical output, again either a '1' or '0'.
Recall the following basic logical operations, multiplication denotes the AND operation, addition denotes the OR operation:
\begin{equation*}
    A \cdot A = A, A + A = A, A + \overline{A} = 1, A \cdot \overline{A} = 0, \overline{\overline{A}} = A
\end{equation*}

Using these basic definitions, we can define all of the logic gates described above as:

\begin{itemize}
    \item [AND: ]{$Q = A \cdot B$}
    \item [OR: ]{$Q = A + B$}
    \item [NOT: ]{$Q = \overline{A}$}
    \item [NAND: ]{$Q = \overline{A \cdot B}$}
    \item [NOR: ]{$Q = \overline{A + B}$}
    \item [XOR: ]{$Q = A \oplus B$}
    \item [XNOR:]{$Q = \overline{A \oplus B}$}
\end{itemize}

\begin{example}[Logic Gate Equivalency]
    In this example, we will be breaking down the XOR gate into it's composite boolean algebra expressions and logic gates.
    From Table \ref{tab:xor_truth_table} we can see this gate can be represented by the boolean algebra equation:
    
    \begin{equation*}
        Q = A \cdot \overline{B} + \overline{A} \cdot B
    \end{equation*}
    
    This garners the logic gate equality shown below:

    \includegraphics[height=3.5in]{digital_logic/XORGateBreakdown.png}
\end{example}

    \subsection[]{Logical Optimization}
    It is possible to represent any logical problem using an expression containing the appropriate order of AND and OR operations.
    However, for arbitrary truth tables and problems, this can create a lengthy process that is cumbersome, hard to write and follow, and can lead to extensive errors.
    This expression can also be needlessly inefficient and computationally expensive for calculators.
    Therefore, we can implement some strategies to reduce the computational load and optimize an arbitrary expression so we can improve computational efficiency and performance.

    For this process, two methods can be used: algebraic optimization and Karnaugh mapping.
    The former can be done by hand for relatively simple problems, or by a computer analysis when there are a large number of binary inputs.
    The latter is most commonly done by hand and drastically reduces the size of a truth table.
    This can make the logical problem easier to understand and represent.
    However, this method is limited to a maximum of four binary inputs.

    Let's examine a problem where we are given the arbitrary truth table shown in Table \ref{tab:optimize_table}.

    \begin{table}
        \labtab{optimize_table}
        \begin{tabular}{c c c c | c}
            \toprule
            Input D & Input C & Input B & Input A & Output \\
            \midrule
                0    &    0     &    0     &    0     &    1    \\
                0    &    0     &    0     &    1     &    0    \\
                0    &    0     &    1     &    0     &    0    \\
                0    &    0     &    1     &    1     &    1    \\
                0    &    1     &    0     &    0     &    0    \\
                0    &    1     &    0     &    1     &    0    \\
                0    &    1     &    1     &    0     &    0    \\
                0    &    1     &    1     &    1     &    0    \\
                1    &    0     &    0     &    0     &    1    \\
                1    &    0     &    0     &    1     &    1    \\
                1    &    0     &    1     &    0     &    1    \\
                1    &    0     &    1     &    1     &    1    \\
                1    &    1     &    0     &    0     &    1    \\
                1    &    1     &    0     &    1     &    0    \\
                1    &    1     &    1     &    0     &    0    \\
                1    &    1     &    1     &    1     &    1    \\
            \bottomrule
        \end{tabular}
        \caption[Optimization Truth Table]{An arbitrary truth table ripe for optimization}
    \end{table}

    We can begin exploring the algebraic optimization by writing the algebraic expression for the true values of the table:
    
    \begin{equation*}
        Q = \overline{ABCD} + C + A + AC + AB + ABD + ABC + ABCD 
    \end{equation*}

    Using algebraic simplification:

    \begin{align}
        Q &= \cancel{\overline{ABCD}} + \cancel{ABCD} + CD + A(1 + C + B + BD + \cancel{BC}) \nonumber \\
          &= C + A(1 + C + B + BD) \nonumber \\
          &= C + A + \cancel{AC} + AB + BD \nonumber \\
        Q &= C + A + AB + ABD \nonumber
    \end{align}

    \marginnote[-1.5in]{Here, you will notice some AND expressions have been cancelled out (re: $BC$ and $AC$).
    This has occurred because the expressions $ B + C + BC$ and $A + C + AC$ simplify down to the first OR operation.
    Let's explore this by drawing out the truth table for these expressions: \\
    \begin{tabular}{c c | c}
        \toprule
        $B$ & $C$ & $B+C+BC$ \\
        \midrule
        0 & 0 & 0 \\
        0 & 1 & 1 \\
        1 & 0 & 1 \\
        1 & 1 & 1 \\
        \bottomrule
    \end{tabular} \\
    You will notice that this truth table is the exact same for the OR gate (Table \ref{tab:or_truth_table}) and therefore proves the simplification and cancellation of the AND operation.
    }

    This expression is complicated and would require three OR gates, and three AND gates to represent.
    Let's see if we can simplify this using a Karnaugh map.

    \paragraph*{Karnaugh Maps} or K-maps, are condensed representations of truth tables that combine up to four distinct inputs into a two-dimensional table.
    These not only condense truth tables into a simpler form for easier understanding, but they can simultaneously simplify the algebraic expression for the truth table.
    K-Maps have a special property where if any logical true outputs that are grouped together in powers of 2 can be combined into a simpler AND operation.

    For the example found in Table \ref{tab:optimize_table}, the corresponding K-Map would be:

    \begin{karnaugh-map}(label=corner)[4][4][1][$B$][$A$][$D$][$C$]
        \manualterms{1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1}
        \implicant{12}{14}
        \implicantcorner
    \end{karnaugh-map}

    The highlighted groupings mean the truth table from before can be represented by the algebraic expression:

    \begin{equation*}
        Q = AB + \overline{BD}
    \end{equation*}

    \pagelayout{wide} % Remove margins

    \begin{example}[Applied Logic Gate Simplification] \label{ex:advanced-logic-gates}
        For this example, we will be combining everything we have learned through this section into a single problem.
        We will start with the logic gate diagram shown below:
        
        \begin{center}
            \includegraphics[height=2.5in]{digital_logic/AdvancedGatesEx.png}
        \end{center}

        We can represent these gates with the expression:

        \begin{equation*}
            Q = (A+B)C \oplus \overline{D}
        \end{equation*}

        Which expands to:

        \begin{equation*}
            Q = \left((AC + BC)\overline{D}\right) + \left((\overline{AB} + \overline{C})D\right)
        \end{equation*}

        This expression is a little complicated and is not ideal to determine what inputs will result in our desired outputs.
        Therefore, we will construct a truth table to represent these logic gates so that we can directly check a given output with an expected output.

        \begin{center}
            \begin{tabular}{c c c c | c}
                \toprule
                Input D & Input C & Input B & Input A & Output \\
                \midrule
                    0    &    0     &    0     &    0     &    0    \\
                    0    &    0     &    0     &    1     &    1    \\
                    0    &    0     &    1     &    0     &    0    \\
                    0    &    0     &    1     &    1     &    0    \\
                    0    &    1     &    0     &    0     &    0    \\
                    0    &    1     &    0     &    1     &    1    \\
                    0    &    1     &    1     &    0     &    1    \\
                    0    &    1     &    1     &    1     &    0    \\
                    1    &    0     &    0     &    0     &    0    \\
                    1    &    0     &    0     &    1     &    1    \\
                    1    &    0     &    1     &    0     &    1    \\
                    1    &    0     &    1     &    1     &    0    \\
                    1    &    1     &    0     &    0     &    0    \\
                    1    &    1     &    0     &    1     &    1    \\
                    1    &    1     &    1     &    0     &    1    \\
                    1    &    1     &    1     &    1     &    0    \\
                \bottomrule
            \end{tabular}
        \end{center}

        Both the representative expression and truth table are a little large and inefficient.
        If we look at the representative expression, we will notice that it is difficult, if not impossible, to algebraically simplify by hand. 
        So, we will simplify the truth table with a Karnaugh map and determine the simplified algebraic expression from there.
        
        \begin{center}
            \begin{karnaugh-map}(label=corner)[4][4][1][$B$][$A$][$D$][$C$]
                \manualterms{0,0,0,0,1,1,1,1,0,1,1,1,0,0,0,0}
                \implicant{4}{6}
                \implicant{9}{11}
                \implicant{11}{10}
            \end{karnaugh-map}
        \end{center}

        From the K-map, we can simplify the algebraic expression for the logic diagram as:

        \begin{equation*}
            Q = \overline{C}D + BC\overline{D} + AC\overline{D}
        \end{equation*}

        This expression is the most basic form for the logic diagram and now we can check any arbitrary value of $A$, $B$, $C$, or $D$ without have to directly look it up in the truth table or run it through the logic diagram.
    \end{example}

    \pagelayout{margin} % Restore margins

\section[]{Multiplexing and Demultiplexing}